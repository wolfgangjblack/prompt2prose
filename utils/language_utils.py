from utils.agents import context_agent, prose_agent, story_agent, length_agent, flow_agent

def generate_story(beats, min_words=100, max_words=150, max_attempts=5):
    """
    Generates a complete story from a list of story beats.
    For each pair of beats:
      1. Use ProseAgent to generate a connecting passage.
      2. Use StoryAgent to verify consistency; if not, retry.
      3. Use LengthAgent to check that the passage meets length requirements; if not, retry.
    The process is recursive for each connecting passage until both checks return "True" or max_attempts is reached.
    
    Arguments:
      - beats: A list of story beat strings.
      - min_words, max_words: The desired word count range for connecting passages.
      - max_attempts: How many times to retry a connecting passage before giving up.
    
    Returns:
      - The final composed story as a string.
    """
    final_story = ""
    current_passage = None
    cost = 0
    # For each pair of beats, generate and validate a connecting passage.
    for i in range(len(beats) - 1):
        print(f"working on beat {i}")
        if i == 0:
            context, c = context_agent(beats[i])
        else:
            context, c = context_agent(beats[i], context)
        
        cost += c
        beat_a = beats[i]
        beat_b = beats[i + 1]
        
        for attempt in range(max_attempts):
            generated_passage, c = prose_agent(current_passage, beat_a, beat_b, context_summary=context)
            # print(f"ProseAgent output (iteration {i+1}, attempt {attempt+1}):\n{generated_passage}\n")
            cost += c
            # Check consistency
            consistency,c = story_agent(generated_passage, [beat_a, beat_b])
            # print(f"StoryAgent consistency check returned: {consistency}")
            if consistency != "True":
                print("Inconsistency detected; regenerating passage...\n")
                continue  # Rerun prose_agent
            cost += c
            # Check length
            length_ok,c = length_agent(generated_passage, min_words, max_words)
            cost += c
            #
            if length_ok != "True":
                print("Length requirement not met; regenerating passage...\n")
                continue  # Rerun prose_agent
            
            # If both checks pass, break out of the retry loop.
            break
        else:
            # If max_attempts were reached without both checks passing, raise an error or accept the last generated passage.
            print(f"Max attempts reached for beats {i}. Accepting the last generated passage.")
        
        final_story += f"{generated_passage}\n"
        current_passage = generated_passage  # Use current valid passage for continuity if needed.
    
    # Append the final beat.
    return final_story, cost


def story_pipeline(beats, min_words=100, max_words=150, max_attempts=10):
    """
    Generates a complete edited story using the agents we've designed above. 
    This improves upon the final story generated by generate_story by adding
    in the flow_agent
    """
    max_edit_words = max_words * len(beats)
    
    final_story, total_cost = generate_story(beats, min_words, max_words, max_attempts)

    edited_story, c = flow_agent(final_story, max_edit_words)

    return edited_story, total_cost + c


